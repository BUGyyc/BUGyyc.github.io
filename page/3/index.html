<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Coder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Coder">
<meta property="og:url" content="http://bugyyc.com/posts/coder/page/3/index.html">
<meta property="og:site_name" content="Coder">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Delevin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Coder" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Coder</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://BUGyyc.com/posts/coder"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-05.游戏编程/游戏开发技巧/插值方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95/">插值方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>插值方法</p>
<p>在网络导致的掉帧情况下，造成游戏坐标与服务器下发坐标不一致是时常发生的，<br>这个时候选择平滑过渡到目标坐标是比较合适的方法。</p>
<p><a href="http://gad.qq.com/program/translateview/7168875" target="_blank" rel="noopener">http://gad.qq.com/program/translateview/7168875</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95/" data-id="ckbp3mqj1000548twgh60g67g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-05.游戏编程/游戏开发技巧/物理引擎的确定性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%E7%9A%84%E7%A1%AE%E5%AE%9A%E6%80%A7/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%E7%9A%84%E7%A1%AE%E5%AE%9A%E6%80%A7/">物理引擎的确定性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%E7%9A%84%E7%A1%AE%E5%AE%9A%E6%80%A7/" data-id="ckbp3mqj2000648twf7ao4ghx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-05.游戏编程/游戏开发技巧/网络同步问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">网络同步问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在进行多人游戏开发过程中，我们期望游戏在不同设备上保持一致的表现，或者说是结果一致，许多动作类游戏，多人游戏的要求就更高，我们不希望不同客户端看到的结果是不一样的。<br>这要求我们要保证物理计算的一致，包括随机数等等</p>
<ul>
<li><p>预测式输入，我们不希望长时间等待服务器响应，当然我们在网络波动延迟较大的情况下，可以做出相应的提示，让玩家感知到当前网络较差，</p>
</li>
<li><p>插值处理，线性的插值，在单纯的直线运动，我们可以直接采取，k*x+b = y的方式，得到中间值(x,y)。在update（或者协程中）中去lerp</p>
</li>
<li><p>光滑曲线的插值计算</p>
</li>
<li><p>三次样条插值，填补掉帧或延迟造成坐标跳跃，所以我们希望计算中间值，确定平滑曲线，得到最终的路径点</p>
</li>
<li><p>定点数计算，设备浮点数计算是有误差的，所以必要时候舍弃设备自带的四舍五入方式，采取手写确定，保持计算一致，客户端，有时候喜欢随机值单独计算，例如，玩家攻击的是否暴击，随机种子保证随机序列，只要保证，随机执行的顺序</p>
</li>
</ul>
<hr>
<h1 id="插值与补偿"><a href="#插值与补偿" class="headerlink" title="插值与补偿"></a>插值与补偿</h1><h2 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h2><p><img src="https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC.jpg" alt="(path/to/image.png)"></p>
<p>直线式的补偿，可以满足要求不高的同步游戏。<br>线性插值其实是取当前点与网络目标点，得到线段，并且得到线段的线性函数，k*x+b = y 。只需求解k,b，在进行插值时，我们已知两个点（当前点与网络同步过来的目标点），已知两个不重合的点，可以求出直线方程，所有k,b求出结果。<br><img src="https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/ztest7.gif" alt="(path/to/image.png)"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;服务器的帧消息</span><br><span class="line">onUdpFrameInfo(bytes) &#123;</span><br><span class="line">    let msg ...</span><br><span class="line">    &#x2F;&#x2F;执行同步逻辑</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;对应渲染鸡，更改目标坐标</span><br><span class="line">    this.onRenderAll(index, msg);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染需要移动的鸡</span><br><span class="line">onRenderAll(index, msg) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;转成对象</span><br><span class="line">    let data &#x3D; this.byteData2Object(...);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;发出消息更改鸡的目标坐标</span><br><span class="line">    SoulGame.EventDispatcher.dispatchEvent(&quot;Sync_Pos&quot;, data);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;鸡对象的部分代码</span><br><span class="line"></span><br><span class="line">onLoad() &#123;</span><br><span class="line">    SoulGame.EventDispatcher.addEventListener(&quot;Sync_Pos&quot;, this.onUpdatePos, this);  </span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新目标点</span><br><span class="line">onUpdatePos(data) &#123;</span><br><span class="line">    if (parseInt(data.id) &#x3D;&#x3D; this.id) &#123;</span><br><span class="line">        &#x2F;&#x2F;除以100,是因为服务器整数计算，放大了100倍，减少浮点数</span><br><span class="line">        let pos &#x3D; (data.pos &#x2F; 100);</span><br><span class="line">        this.targetPos &#x3D; pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每帧逻辑</span><br><span class="line">onEnterFrame() &#123;</span><br><span class="line">    &#x2F;&#x2F;插值补偿</span><br><span class="line">    let vec &#x3D; this.node.position.lerp(this.targetVec, 0.5);</span><br><span class="line">    this.node.position &#x3D; vec;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">lerp官方介绍</span><br><span class="line">&#x2F;**</span><br><span class="line">!#en TODO</span><br><span class="line">!#zh 线性插值。</span><br><span class="line">@param to to</span><br><span class="line">@param ratio the interpolation coefficient</span><br><span class="line">@param out optional, the receiving vector </span><br><span class="line">*&#x2F;</span><br><span class="line">lerp(to: Vec2, ratio: number, out?: Vec2): Vec2;</span><br></pre></td></tr></table></figure>

<h3 id="线性内插"><a href="#线性内插" class="headerlink" title="线性内插"></a>线性内插</h3><pre><code>线性内插法的基本计算过程是根据一组已知的未知函数自变量的值和它相对应的函数值， 利用等比关系去求一种求未知函数其他值的近似计算方法，是一种求位置函数逼近数值的求解方法。
公式表示：Y=Y1+（Y2-Y1）×（X-X1）/（X2-X1）</code></pre><h3 id="线性外插"><a href="#线性外插" class="headerlink" title="线性外插"></a>线性外插</h3><pre><code>外插亦称外推，是插值法的基本类型之一。当自变量 x 不是插值节点，且 x 位于插值区间之外时，用插值函数 P(x) 的值作为被插值函数 f(x) 的近似值，称为外插或外推。</code></pre><p><a href="https://www.cnblogs.com/luluathena/archive/2010/11/27/1889906.html" target="_blank" rel="noopener">https://www.cnblogs.com/luluathena/archive/2010/11/27/1889906.html</a></p>
<h2 id="曲线插值"><a href="#曲线插值" class="headerlink" title="曲线插值"></a>曲线插值</h2><p>游戏对象的运行轨迹很多情况下是曲线，所以上面所提及的线性插值是无法满足需求的，我们希望通过一定数量的点模拟出非常真实光滑的曲线轨迹，下面将介绍几个常用的曲线插值的方法。</p>
<h3 id="二次样条插值"><a href="#二次样条插值" class="headerlink" title="二次样条插值"></a>二次样条插值</h3><p>已知不在同一直线上的三点P1、P2、P3，要求通过给定的这三点定义一条抛物线。</p>
<p>表达式为：</p>
<p>P(t) = A1 + A2<em>t + A3</em>t^2    (0≤t≤1) </p>
<p>A1、A2、A3为表达式的系数，且是向量形式。若是二维平面曲线，则为二维向量；若是三维空间曲线，则为三维向量。</p>
<p><img src="https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/ztest13.gif" alt="(path/to/image.png)"></p>
<p><a href="https://blog.csdn.net/zl908760230/article/details/53967828" target="_blank" rel="noopener">https://blog.csdn.net/zl908760230/article/details/53967828</a></p>
<h3 id="三次样条插值"><a href="#三次样条插值" class="headerlink" title="三次样条插值"></a>三次样条插值</h3><p><img src="https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/ztest12.gif" alt="(path/to/image.png)"></p>
<pre><code>值则是形似，每个已知点都必会穿过，但是高阶会出现龙格库塔现象，所以一般采用分段插值。今天我们就来说说这个分段三次样条插值。</code></pre><p>已知四个点，求解出近似的轨迹方程，然后分段取点，客户端按帧去更新点。</p>
<p>表示的公式：</p>
<p>a<em>x^3+b</em>x^2+c*x+d = y;</p>
<p>求解出a,b,c,d系数</p>
<p><a href="https://zhuanlan.zhihu.com/p/62860859" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62860859</a></p>
<p>贪吃蛇的实现方式</p>
<p>客户端与服务器保持一致的三次样条插值方式，服务器采取10帧计算频率，客户端保持30帧左右的更新频率，也就是说客户端插值计算得到空缺帧的中间点，使得蛇可以沿着曲线光滑移动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;帧数据处理（加入战场后，服务器主动下发）</span><br><span class="line">onFrameInfo (msg) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;更新蛇</span><br><span class="line">    this.updateSnakeParams(frameInfos);</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新所有蛇的状态</span><br><span class="line">updateSnakeParams (msg) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (snake) &#123;</span><br><span class="line">        let p &#x3D;  snake.node.convertToNodeSpaceAR(...);</span><br><span class="line">        if (snake._isDead) &#123;&#x2F;&#x2F;蛇死了</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F;插值分段得到的轨迹</span><br><span class="line">            snake.AddBodyPosSvr_Head(p.x,p.y);</span><br><span class="line">            &#x2F;&#x2F;修改蛇头角度</span><br><span class="line">            snake.directTo(...);</span><br><span class="line">            &#x2F;&#x2F;修改蛇的速度</span><br><span class="line">            snake.setSpeed(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;snake脚本</span><br><span class="line"></span><br><span class="line">AddBodyPosSvr_Head(x,y)&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;加到数组头部</span><br><span class="line">    this.m_BodyPosArr_SvrX.unshift(x);</span><br><span class="line">    this.m_BodyPosArr_SvrY.unshift(y);</span><br><span class="line">    &#x2F;&#x2F;将数组进行填补，输出一个新数组</span><br><span class="line">    Utils.resize(this.m_BodyPosArr_SvrX,iEvalCount);</span><br><span class="line">    Utils.resize(this.m_BodyPosArr_SvrY,iEvalCount);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染蛇</span><br><span class="line">rendererSnake()&#123;</span><br><span class="line">    ...</span><br><span class="line">    this.SplineSvr();</span><br><span class="line">    ...</span><br><span class="line">    this.localMove();</span><br><span class="line">    ...</span><br><span class="line">    this.LinearInterpolation();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;样条处理</span><br><span class="line">SplineSvr()&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;三次样条插值</span><br><span class="line">    FitParametricDt(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本地预测式移动</span><br><span class="line">localMove()&#123;</span><br><span class="line">    &#x2F;&#x2F;差值时间</span><br><span class="line">    let curFrameTurnSpeed &#x3D; Game.m_dTurnSpeed;</span><br><span class="line">    let now &#x3D; this.getCurMilliseconds();</span><br><span class="line">    let iTime &#x3D; now - this.m_iLastUpdateTime;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;移动蛇头</span><br><span class="line">    this.updateHead(distantce * scale ,curFrameTurnSpeed * scale);</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将本地预测移动后的结果与服务器结果比较，差异大进行纠错移动</span><br><span class="line">LinearInterpolation()&#123;</span><br><span class="line">    ...</span><br><span class="line">    let real &#x3D; cc.v2(this.m_BodyPosArr_SvrX_Splined[i], this.m_BodyPosArr_SvrY_Splined[i]);</span><br><span class="line">    let now &#x3D; this.m_BodyPosList_Show[i];</span><br><span class="line">    &#x2F;&#x2F;差一大的话进行纠错</span><br><span class="line">    let result &#x3D; Utils.lerp_Perc(now, real, 0.016 * this.g_LinearInterpolation);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;进行纠错移动</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>三次样条插值源代码</p>
<p><a href="https://github.com/BUGyyc/myMd/blob/master/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC/CubicSpline.h" target="_blank" rel="noopener">https://github.com/BUGyyc/myMd/blob/master/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC/CubicSpline.h</a></p>
<hr>
<h1 id="确定性问题"><a href="#确定性问题" class="headerlink" title="确定性问题"></a>确定性问题</h1><p>多数物理引擎在不采取任何手段的情况下，是无法保证确定性的。</p>
<p>这意味着</p>
<p>相同的状态 + 相同的输入 = 不同输出结果</p>
<p>造成这种现象的原因包括但不限于：</p>
<ul>
<li>浮点数精度问题</li>
<li>随机数问题</li>
<li>时间的细微差异问题</li>
</ul>
<h2 id="浮点数计算"><a href="#浮点数计算" class="headerlink" title="浮点数计算"></a>浮点数计算</h2><p>浮点计算因为设备硬件差异，会有计算误差，所以必要时候，需要定点计算，提供一个定点计算数学库。</p>
<p>浮点数计算不仅仅在不同设备上存在不一致的可能性，甚至是速度也不如整数计算快，所以往往我们把浮点数放大特定倍数，例如放大1000倍，好比是在原有的基础上保留三位小数，客户端接收到放大后的数据，只需要缩小即可</p>
<h2 id="随机数问题"><a href="#随机数问题" class="headerlink" title="随机数问题"></a>随机数问题</h2><p>事实上，大多数在计算领域用到的随机数都不是真正随机的，而是由伪随机数生成器生成的。伪随机数生成器都是确定性的算法，并且是唯一一种可不需要使用外界熵，诸如热噪声或用户行为来生成随机数的算法。</p>
<h3 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h3><p>伪随机数生成器通过对一个内部状态进行计算，来生成一个看似随机的数列。这个初始的状态被称作种子。为一个特定算法选一个好种子是非常困难的。通常情况下，算法使用返回的随机值作为内部状态。因为这个内部状态是有限的，伪随机数生成器会在一些情况下重复。一个随机数生成器的周期就是它开始重复之前所能返回的随机数个数。一个使用n位内部状态值得伪随机数算法最多只有 2^n 的周期。用相同的种子开始一个伪随机数生成器，将得到相同的随机数数列，不过这个特性在调试其他模块时非常有用。当伪随机数生成器需要一个“随机”的种子时，通过会使用系统或者外部硬件的熵来源。</p>
<h3 id="随机数生成算法"><a href="#随机数生成算法" class="headerlink" title="随机数生成算法"></a>随机数生成算法</h3><ul>
<li><p>平方取中法：取一个10位数作为种子，取平方，返回中间10位作为下一个数和种子，这个算法有统计缺陷，已经不再使用</p>
</li>
<li><p>线性同余生成器（LCG）：<br><img src="https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190918142750.png" alt="(path/to/image.png)"></p>
</li>
<li><p>WELL算法：<br><img src="https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190918143206.png" alt="(path/to/image.png)"></p>
</li>
</ul>
<hr>
<h1 id="传输协议的选择"><a href="#传输协议的选择" class="headerlink" title="传输协议的选择"></a>传输协议的选择</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP提供了一种可靠的面向连接的字节流传输层服务。<br>TCP将用户数据打包构成报文段，它发送数据后启动一个定时器，另一端对收到的数据进行确认，对失序的数据进行重新排序，丢弃重复数据，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端的检验和。</p>
<h3 id="为什么TCP具有可靠性"><a href="#为什么TCP具有可靠性" class="headerlink" title="为什么TCP具有可靠性"></a>为什么TCP具有可靠性</h3><ul>
<li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。</li>
<li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。</li>
<li>TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输<br>过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到<br>此报文段（希望发端超时并重发）。</li>
<li>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此 TCP报文段<br>的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以<br>正确的顺序交给应用层。</li>
<li>既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。</li>
<li>TCP还能提供流量控制。 TCP连接的每一方都有固定大小的缓冲空间。 TCP的接收端只</li>
<li>允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲<br>区溢出。</li>
</ul>
<p><a href="https://github.com/BUGyyc/myMd/blob/master/%E7%BD%91%E7%BB%9C/TCP.md" target="_blank" rel="noopener">https://github.com/BUGyyc/myMd/blob/master/%E7%BD%91%E7%BB%9C/TCP.md</a></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP是面向报文的。<br>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。<br>既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p>
<p><a href="https://github.com/BUGyyc/myMd/blob/master/%E7%BD%91%E7%BB%9C/UDP.md" target="_blank" rel="noopener">https://github.com/BUGyyc/myMd/blob/master/%E7%BD%91%E7%BB%9C/UDP.md</a></p>
<h2 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h2><p>TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果：</p>
<ul>
<li>选择性重传 vs 全部重传: TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。</li>
<li>快速重传：发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。</li>
<li>延迟ACK vs 非延迟ACK：TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。</li>
</ul>
<p><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">https://github.com/skywind3000/kcp</a></p>
<h2 id="UDP实现可靠传输问题"><a href="#UDP实现可靠传输问题" class="headerlink" title="UDP实现可靠传输问题"></a>UDP实现可靠传输问题</h2><p>事实上，有不少行家指出，UDP基础上实现可靠传输存在许多无法预料的问题<br><img src="https://raw.githubusercontent.com/BUGyyc/MyGallery/master/res/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190918144901.png" alt="(path/to/image.png)"></p>
<hr>
<h1 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h1><h2 id="帧锁定与事件锁定"><a href="#帧锁定与事件锁定" class="headerlink" title="帧锁定与事件锁定"></a>帧锁定与事件锁定</h2><h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><h2 id="锁步协议"><a href="#锁步协议" class="headerlink" title="锁步协议"></a>锁步协议</h2><hr>
<h1 id="Unet"><a href="#Unet" class="headerlink" title="Unet"></a>Unet</h1><p>Unity官方提供了NetworkManager的方式<br>如下运行结果：左边操作，右边同步更新</p>
<p>git</p>
<p><a href="https://github.com/BUGyyc/SyncProject" target="_blank" rel="noopener">https://github.com/BUGyyc/SyncProject</a></p>
<hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://blog.csdn.net/yupu56/article/details/86822511" target="_blank" rel="noopener">https://blog.csdn.net/yupu56/article/details/86822511</a></p>
<p><a href="https://blog.codingnow.com/2006/04/sync.html" target="_blank" rel="noopener">https://blog.codingnow.com/2006/04/sync.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28617637" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28617637</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/44341238" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44341238</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/49482294" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49482294</a></p>
<p><a href="http://gad.qq.com/program/translateview/7168875" target="_blank" rel="noopener">http://gad.qq.com/program/translateview/7168875</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/49483467" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49483467</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/49483875" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49483875</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50440945" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50440945</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" data-id="ckbp3mqj2000748twa7j04zmu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-05.游戏编程/游戏开发技巧/网络相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/">网络相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>帧锁定与事件锁定</p>
<p>时间同步的策略</p>
<p>实时策略网络协议</p>
<p>锁步协议</p>
<hr>
<p>出自游戏编程精粹3</p>
<p>网络拥塞</p>
<p><a href="https://blog.csdn.net/sicofield/article/details/9708383" target="_blank" rel="noopener">https://blog.csdn.net/sicofield/article/details/9708383</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/" data-id="ckbp3mqj3000848twaf5s7b8w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-05.游戏编程/游戏开发技巧/随机数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E9%9A%8F%E6%9C%BA%E6%95%B0/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E9%9A%8F%E6%9C%BA%E6%95%B0/">随机数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>可预测随机数</p>
<p>利用随机种子</p>
<p>【从随机数到自然界中的噪声】<a href="https://zhuanlan.zhihu.com/p/77628759" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77628759</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/05.%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/%E9%9A%8F%E6%9C%BA%E6%95%B0/" data-id="ckbp3mqj4000948tw6i3w6zs5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-02.编程语言/C#" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C#/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C#/">C#要点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/</a></p>
<p>unsafe C# 中unsafe类型</p>
<p><a href="https://docs.microsoft.com/zh-cn/previous-versions/618ayhy6(v=vs.120)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/618ayhy6(v=vs.120)</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/index" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/index</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C#/" data-id="ckbp3mqjd000a48twbs3868vl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-02.编程语言/C++" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/">C++要点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/" data-id="ckbp3mqje000b48twd9w4dmsn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-02.编程语言/Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java精要</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>hash \hash碰撞</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" data-id="ckbp3mqji000d48twd0o3gn9e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-02.编程语言/JavaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript要点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.w3cschool.cn/javascript/javascript-skillmap.html" target="_blank" rel="noopener">https://www.w3cschool.cn/javascript/javascript-skillmap.html</a></p>
<h1 id="javascript-中的类型"><a href="#javascript-中的类型" class="headerlink" title="javascript 中的类型"></a>javascript 中的类型</h1><p>Undefined NULL Number String Boolean Object</p>
<h2 id="typeof-与-instanceof"><a href="#typeof-与-instanceof" class="headerlink" title="typeof 与 instanceof"></a>typeof 与 instanceof</h2><p><a href="http://jartto.wang/2019/01/17/js-typeof/" target="_blank" rel="noopener">http://jartto.wang/2019/01/17/js-typeof/</a></p>
<h1 id="typeof-判断返回以下结果"><a href="#typeof-判断返回以下结果" class="headerlink" title="typeof 判断返回以下结果"></a>typeof 判断返回以下结果</h1><ul>
<li>udefined ， 值未定义</li>
<li>boolean , 值为布尔型</li>
<li>string , 值为字符串</li>
<li>number ， 值为数值类型</li>
<li>object , 值为对象类型或者null，null是特殊值，被认为是空的对象引用</li>
<li>function , 值为函数</li>
</ul>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ul>
<li>push() 尾部添加元素</li>
<li>unshift() 数组头部添加元素</li>
<li>concat() 合并两个数组</li>
<li>pop() 删除尾部元素并返回</li>
<li>shift() 删除头部元素并返回</li>
</ul>
<p>值类型用 typeOf 检测类型，引用类型用 instanceOf 检测类型</p>
<hr>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>内层函数可以访问外层函数局部变量，外层函数不能访问内层函数局部变量</p>
<hr>
<h1 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h1><p>标记回收、引用计数</p>
<p><a href="https://segmentfault.com/a/1190000019276047" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019276047</a></p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h2 id="减少垃圾回收"><a href="#减少垃圾回收" class="headerlink" title="减少垃圾回收"></a>减少垃圾回收</h2><h3 id="数组优化"><a href="#数组优化" class="headerlink" title="数组优化"></a>数组优化</h3><p>将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p>
<p><a href="https://www.cnblogs.com/zhwl/p/4664604.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhwl/p/4664604.html</a></p>
<hr>
<h1 id="执行域"><a href="#执行域" class="headerlink" title="执行域"></a>执行域</h1><p>var 局部变量<br>出现变量提升</p>
<hr>
<h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>函数的参数以数组形式传递</p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>函数的参数直接传递</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><a href="https://www.runoob.com/w3cnote/js-call-apply-bind.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/js-call-apply-bind.html</a></p>
<hr>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>JavaScript 变量可以是局部变量或全局变量。</p>
<p>私有变量可以用到闭包。</p>
<p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    var counter &#x3D; 0;</span><br><span class="line">    function plus() &#123;counter +&#x3D; 1;&#125;</span><br><span class="line">    plus();    </span><br><span class="line">    return counter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为1<br>counter被修改了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;;</span><br><span class="line">　　alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure>
<p>输出为 The Window<br>name没有被修改</p>
<p>因为：<br>getNameFunc: function() {//假设函数名为Ａ<br>return function()/<em>假设函数名为Ｂ</em>/ { return this.name; };<br>}<br>在函数里面构建函数的时候，闭包产生。<br>在函数Ｂ内调用函数Ａ的this.name,由于函数Ａ没有name属性，所以就去找全局变量name，找到了，所以返回“The Window”，要是没有找到，则返回“undefined”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that &#x3D; this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;;</span><br><span class="line">　　alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure>
<p>var <em>this = this;<br>return function() { return <em>this.name +”</em></em>“+ this.name; };</p>
<p>父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></p>
<p>this的指向是由它所在函数调用的上下文决定的，而不是由它所在函数定义的上下文决定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line">var object &#x3D; &#123;</span><br><span class="line">    name: &quot;My Object&quot;,</span><br><span class="line">    getNameFunc: function () &#123;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure>

<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 让我们从一个自身拥有属性a和b的函数里创建一个对象o：</span><br><span class="line">let f &#x3D; function () &#123;</span><br><span class="line">   this.a &#x3D; 1;</span><br><span class="line">   this.b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 这么写也一样</span><br><span class="line">function f() &#123;</span><br><span class="line">  this.a &#x3D; 1;</span><br><span class="line">  this.b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">let o &#x3D; new f(); &#x2F;&#x2F; &#123;a: 1, b: 2&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在f函数的原型上定义属性</span><br><span class="line">f.prototype.b &#x3D; 3;</span><br><span class="line">f.prototype.c &#x3D; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不要在 f 函数的原型上直接定义 f.prototype &#x3D; &#123;b:3,c:4&#125;;这样会直接打破原型链</span><br><span class="line">&#x2F;&#x2F; o.[[Prototype]] 有属性 b 和 c</span><br><span class="line">&#x2F;&#x2F;  (其实就是 o.__proto__ 或者 o.constructor.prototype)</span><br><span class="line">&#x2F;&#x2F; o.[[Prototype]].[[Prototype]] 是 Object.prototype.</span><br><span class="line">&#x2F;&#x2F; 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null</span><br><span class="line">&#x2F;&#x2F; 这就是原型链的末尾，即 null，</span><br><span class="line">&#x2F;&#x2F; 根据定义，null 就是没有 [[Prototype]]。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 综上，整个原型链如下: </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype---&gt; null</span><br><span class="line"></span><br><span class="line">console.log(o.a); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; a是o的自身属性吗？是的，该属性的值为 1</span><br><span class="line"></span><br><span class="line">console.log(o.b); &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; b是o的自身属性吗？是的，该属性的值为 2</span><br><span class="line">&#x2F;&#x2F; 原型上也有一个&#39;b&#39;属性，但是它不会被访问到。</span><br><span class="line">&#x2F;&#x2F; 这种情况被称为&quot;属性遮蔽 (property shadowing)&quot;</span><br><span class="line"></span><br><span class="line">console.log(o.c); &#x2F;&#x2F; 4</span><br><span class="line">&#x2F;&#x2F; c是o的自身属性吗？不是，那看看它的原型上有没有</span><br><span class="line">&#x2F;&#x2F; c是o.[[Prototype]]的属性吗？是的，该属性的值为 4</span><br><span class="line"></span><br><span class="line">console.log(o.d); &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; d 是 o 的自身属性吗？不是，那看看它的原型上有没有</span><br><span class="line">&#x2F;&#x2F; d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有</span><br><span class="line">&#x2F;&#x2F; o.[[Prototype]].[[Prototype]] 为 null，停止搜索</span><br><span class="line">&#x2F;&#x2F; 找不到 d 属性，返回 undefined</span><br></pre></td></tr></table></figure>
<p>优先找自身属性，然后再在原型链上找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;&#125;</span><br><span class="line">doSomething.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">var doSomeInstancing &#x3D; new doSomething();</span><br><span class="line">doSomeInstancing.prop &#x3D; &quot;some value&quot;;</span><br><span class="line">console.log(&quot;doSomeInstancing.prop:      &quot; + doSomeInstancing.prop);</span><br><span class="line">console.log(&quot;doSomeInstancing.foo:       &quot; + doSomeInstancing.foo);</span><br><span class="line">console.log(&quot;doSomething.prop:           &quot; + doSomething.prop);</span><br><span class="line">console.log(&quot;doSomething.foo:            &quot; + doSomething.foo);</span><br><span class="line">console.log(&quot;doSomething.prototype.prop: &quot; + doSomething.prototype.prop);</span><br><span class="line">console.log(&quot;doSomething.prototype.foo:  &quot; + doSomething.prototype.foo);</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://blog.fundebug.com/2017/07/17/10-javascript-difficulties/" target="_blank" rel="noopener">https://blog.fundebug.com/2017/07/17/10-javascript-difficulties/</a></p>
<p><a href="https://juejin.im/entry/588037d38d6d810058af5d01" target="_blank" rel="noopener">https://juejin.im/entry/588037d38d6d810058af5d01</a></p>
<hr>
<h1 id="Js中的变量与对象"><a href="#Js中的变量与对象" class="headerlink" title="Js中的变量与对象"></a>Js中的变量与对象</h1><p>在Js中所有的变量都可以当作对象使用，除了两个例外null和undefined</p>
<pre><code>function foo(){}
foo.a = 1;</code></pre><h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><pre><code>var a = {b:1};
a[&apos;b&apos;]; //1</code></pre><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>delete ，remove 数组中删除，数组长度不会变，被删除的项变为Undefined</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>Js 不包含传统的类继承模型，而是使用prototype原型模型</p>
<h2 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h2><p>Js的属性查找，会向上遍历查找原型链，直到找到给定名称的属性为止。<br>到达原型链顶部Object.prototype，未找到就返回Undefined.<br>优先查找自身，然后再查找原型链</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是Js中的一种对象，它可以像值一样传递。</p>
<h1 id="This"><a href="#This" class="headerlink" title="This"></a>This</h1><p>执行上下文</p>
<h1 id="闭包与引用"><a href="#闭包与引用" class="headerlink" title="闭包与引用"></a>闭包与引用</h1><pre><code>for(var i = 0;i&lt;10;i++){
    setTimeout(function(){
        console.log(i);
    },1000);
}

for(var i =0;i&lt;10;i++){
    (function(a){
        setTimeout(function(){
            console.log(a);
        },1000)
    })(i);
}

for(var i = 0;i&lt;10;i++){
    setTimeout(
        (function(a){
            return function(){
                console.log(a);
            }
        })(i),1000)
}</code></pre><h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>var的问题，Js先编译再执行<br>建议使用let</p>
<h1 id="数组的操作技巧"><a href="#数组的操作技巧" class="headerlink" title="数组的操作技巧"></a>数组的操作技巧</h1><p>Js中数组是对象，<br>避免使用 for in 遍历数组，因为会查找到原型链上，需要使用hasOwnProperty</p>
<h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><pre><code>Array.prototype.push.apply(arr1,arr2)
//相当于如下
arr1 = arr1 + arr2//arr1包含1，2</code></pre><h2 id="数组最大值与最小值"><a href="#数组最大值与最小值" class="headerlink" title="数组最大值与最小值"></a>数组最大值与最小值</h2><pre><code>var arr = [1,2,3]
Math.max.apply(Math,arr);//3
Math.min.apply(Math,arr);//1</code></pre><p>delete 与 remove 都不能完全清理干净数组，数组长度依然没变，只是值变成了undefined</p>
<h2 id="Array构造函数"><a href="#Array构造函数" class="headerlink" title="Array构造函数"></a>Array构造函数</h2><h1 id="类型判断与比较"><a href="#类型判断与比较" class="headerlink" title="类型判断与比较"></a>类型判断与比较</h1><p>Js是弱类型语言，这就意味着，==操作符会在比较前先进行强制类型转换</p>
<pre><code>“” == “0” //false
0  == “”  //true
0  == &quot;0&quot; //true
false == &quot;false&quot; //false
false == &quot;0&quot;  //true
false == undefined  //false
false == null   //false
null == undefined //true</code></pre><h2 id="typeOf"><a href="#typeOf" class="headerlink" title="typeOf"></a>typeOf</h2><ul>
<li>typeof：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，typeof null也会返回object，大多数的对象类型（数组Array、时间Date等）也会返回object</li>
</ul>
<h2 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h2><p>instanceOf操作符应该仅仅用来比较来自同一个Js上下文的自定义对象。</p>
<ul>
<li>instanceof：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回true，否则 返回false</li>
</ul>
<pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
typeof arr;   
// 返回 &quot;object&quot; 
arr instanceof Array // true
arr.constructor();  //[]</code></pre><h2 id="undefined与null"><a href="#undefined与null" class="headerlink" title="undefined与null"></a>undefined与null</h2><p>两者都表示‘空’，</p>
<p>undefined表示一个值为undefined的类型</p>
<p>在Js中null也是一种数据类型</p>
<h2 id="setTimeout与setInterval"><a href="#setTimeout与setInterval" class="headerlink" title="setTimeout与setInterval"></a>setTimeout与setInterval</h2><p>由于Js是异步的，可以使用setTimeout与setInterval来计划执行函数</p>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="对象转数组"><a href="#对象转数组" class="headerlink" title="对象转数组"></a>对象转数组</h2><pre><code>var arr = Array.prototype.slice.call(arguments)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/" data-id="ckbp3mqjj000e48tw2wmx8f8w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-02.编程语言/Lua" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/" class="article-date">
  <time datetime="2020-06-21T09:48:41.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/">Lua要点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://bugyyc.com/posts/coder/2020/06/21/02.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/" data-id="ckbp3mqjk000f48tw26g64j4o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Creator/" rel="tag">Cocos Creator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LayaBox/" rel="tag">LayaBox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/temp/" rel="tag">temp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/" rel="tag">图形渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/" rel="tag">框架设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/" rel="tag">游戏开发框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" rel="tag">物理引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E5%AD%A6/" rel="tag">计算机数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/" rel="tag">计算机硬件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" rel="tag">计算机科学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%BE%E5%83%8F/" rel="tag">计算机组成原理,图像</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 13.75px;">Android</a> <a href="/tags/C/" style="font-size: 17.5px;">C#</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Cocos-Creator/" style="font-size: 11.25px;">Cocos Creator</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 12.5px;">JavaScript</a> <a href="/tags/LayaBox/" style="font-size: 10px;">LayaBox</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/Unity/" style="font-size: 15px;">Unity</a> <a href="/tags/temp/" style="font-size: 18.75px;">temp</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/" style="font-size: 13.75px;">图形渲染</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/" style="font-size: 11.25px;">框架设计</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" style="font-size: 20px;">游戏开发</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">游戏开发框架</a> <a href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" style="font-size: 12.5px;">物理引擎</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 16.25px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 16.25px;">网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E5%AD%A6/" style="font-size: 11.25px;">计算机数学</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/" style="font-size: 10px;">计算机硬件</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" style="font-size: 10px;">计算机科学</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%BE%E5%83%8F/" style="font-size: 10px;">计算机组成原理,图像</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">软件工程</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 13.75px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/05/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E5%9B%BE%E7%89%87%E7%9A%84%E6%9E%84%E9%80%A0%E5%8F%8A%E5%85%B6%E5%8E%8B%E7%BC%A9%E5%8E%9F%E7%90%86/">常用图片的构造及其压缩原理</a>
          </li>
        
          <li>
            <a href="/2020/06/27/Temporary/%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/">Temporary/关于图片压缩算法</a>
          </li>
        
          <li>
            <a href="/2020/06/27/Temporary/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E7%9A%84%E7%BB%98%E5%88%B6%E6%9D%A5%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%AA%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/">Temporary/从一个图片的绘制来认识一个渲染流程</a>
          </li>
        
          <li>
            <a href="/2020/06/27/Temporary/%E5%85%B3%E4%BA%8EUnity%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F/">Temporary/关于Unity的运行时序</a>
          </li>
        
          <li>
            <a href="/2020/06/27/Temporary/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">Temporary/渲染管线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Delevin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>